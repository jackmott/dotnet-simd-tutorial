# How to leverage SIMD Instructions
### 1. Let the compiler figure it out (auto vectorization)

```rust
// Good chance the compiler will figure this one out
let mut sum = 0;
for i in 0 .. BIGNUM {
    sum += ints[i];
}

// Only if you can tell the compiler floats are ok to vectorize
let mut sum = 0.0;
for i in 0 .. BIGNUM {
    sum += floats[i];
}

// Not likely
let mut funny_sum = 0;
for i in 0 .. BIGNUM {
    if ints[i] > 0 {
        funny_sum += ints[i];
    } else {
        funny_sum -= ints[i];
    }
}

```
### 2. Massage your code to help the compiler figure it out

```rust
let mut funny_sum = 0;
for i in 0 .. BIGNUM {        
    let bit_mask = (x[i] > 0) as u32 * 0xFFFFFFFF;
    let result = (bit_mask & ints[i]) | (!bit_mask & -ints[i]);
    funny_sum += result;    
}

```
### 3. Use assembler
```asm
    movups xmm0, [v1]  
    movups xmm1, [v2]  
    addps xmm0, xmm1   
    movups [v3], xmm0  
```
### 4. Use libraries or special tools (System.Numerics, LinqFaster, etc)
```c#
//System.Numerics, sum array of floats
var state = Vector<float>.Zero;
var count = Vector<float>.Count;

for (int i = 0; i <= source.Length - count; i+=count)
{
    state = state + new Vector<float>(source, i);
}
```

### 5. Intrinsics!
```c#
var ax = Sse.LoadVector128(&axPtr[i]);                       
var bx = Sse.LoadVector128(&bxPtr[i]);                        
Sse.Store(&axPtr[i], Sse.Add(ax, bx));                        
```